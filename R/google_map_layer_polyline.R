
#' Add polyline
#'
#' Add a polyline to a google map
#'
#' @param map a googleway map object created from \code{google_map()}
#' @param data data frame containing at least a \code{polyline} column, or a
#' \code{lat} and a \code{lon} column. If Null, the data passed into
#' \code{google_map()} will be used.
#' @param polyline string specifying the column of \code{data} containing the
#' encoded 'polyline'.
#' @param lat string specifying the column of \code{data} containing the 'latitude'
#' coordinates. Coordinates must be in the order that defines the path.
#' @param lon string specifying the column of \code{data} containing the 'longitude'
#' coordinates. Coordinates must be in the order that defines the path.
#' @param id string specifying the column containing an identifier for a polyline
#' @param geodesic logical
#' @param stroke_colour either a string specifying the column of \code{data}
#' containing the stroke colour of each polyline, or a valid hexadecimal numeric
#' HTML style to be applied to all the polylines
#' @param stroke_opacity either a string specifying the column of \code{data}
#' containing the stroke opacity of each polyline, or a value between 0 and 1 that
#' will be applied to all the polylines
#' @param stroke_weight either a string specifying the column of \code{data}
#' containing the stroke weight of each polyline, or a number indicating the width
#' of pixels in the line to be applied to all the polylines
#' @param info_window string specifying the column of data to display in an info
#' window when a polyline is clicked
#' @param mouse_over string specifying the column of data to display when the
#' mouse rolls over the polyline
#' @param mouse_over_group string specifying the column of data specifying which
#' groups of polylines to highlight on mouseover
#' @param update_map_view logical specifying if the map should re-centre according
#' to the polyline.
#' @param layer_id single value specifying an id for the layer.
#' @param z_index single value specifying where the polylines appear in the layering
#' of the map objects. Layers with a higher \code{z_index} appear on top of those with
#' a lower \code{z_index}. See details.
#' @param digits integer. Use this parameter to specify how many digits (decimal places)
#' should be used for the latitude / longitude coordinates.
#' @param palette a function that generates hex RGB colours given a single number as an input.
#' Used when a variable of \code{data} is specified as a colour
#'
#' @details
#' \code{z_index} values define the order in which objects appear on the map.
#' Those with a higher value appear on top of those with a lower value. The default
#' order of objects is (1 being underneath all other objects)
#'
#' \itemize{
#'   \item{1. Polygon}
#'   \item{2. Rectangle}
#'   \item{3. Polyline}
#'   \item{4. Circle}
#' }
#'
#' Markers are always the top layer
#'
#' @note The lines can be generated by either using an encoded polyline, or by a
#' set of lat/lon coordinates.
#' You sould specify either the column containing an encoded polyline, OR the
#' lat / lon colulmns.
#'
#' Using \code{update_map_view = TRUE} for multiple polylines may be slow, so it
#' may be more appropriate to set the view of the map using the location argument
#' of \code{google_map()}
#'
#' @examples
#' \dontrun{
#'
#' ## using lat/lon coordinates
#'
#' map_key <- "your_api_key"
#'
#' google_map(data = tram_route, key = map_key) %>%
#'   add_polylines(lat = "shape_pt_lat", lon = "shape_pt_lon")
#'
#'
#' ## using encoded polyline and various colour / fill options
#' url <- 'https://raw.githubusercontent.com/plotly/datasets/master/2011_february_aa_flight_paths.csv'
#' flights <- read.csv(url)
#' flights$id <- seq_len(nrow(flights))
#'
#'
#' ## encode the routes as polylines
#' lst <- lapply(unique(flights$id), function(x){
#'   lat = c(flights[flights["id"] == x, c("start_lat")], flights[flights["id"] == x, c("end_lat")])
#'   lon = c(flights[flights["id"] == x, c("start_lon")], flights[flights["id"] == x, c("end_lon")])
#'   data.frame(id = x, polyline = encode_pl(lat = lat, lon = lon))
#' })
#'
#' flights <- merge(flights, do.call(rbind, lst), by = "id")
#'
#' style <- map_styles()$night
#'
#' google_map(key = map_key, style = style) %>%
#'   add_polylines(data = flights, polyline = "polyline", mouse_over_group = "airport1",
#'                stroke_weight = 1, stroke_opacity = 0.3, stroke_colour = "#ccffff")
#'
#'
#' }
#' @export
add_polylines <- function(map,
                          data = get_map_data(map),
                          polyline = NULL,
                          lat = NULL,
                          lon = NULL,
                          id = NULL,
                          geodesic = NULL,
                          stroke_colour = NULL,
                          stroke_weight = NULL,
                          stroke_opacity = NULL,
                          info_window = NULL,
                          mouse_over = NULL,
                          mouse_over_group = NULL,
                          update_map_view = TRUE,
                          layer_id = NULL,
                          z_index = NULL,
                          digits = 4,
                          palette = NULL){

  objArgs <- match.call(expand.dots = F)

  ## PARAMETER CHECKS
  dataCheck(data)
  layer_id <- layerId(layer_id)
  latLonPolyCheck(lat, lon, polyline)

  usePolyline <- isUsingPolyline(polyline)

  if(!usePolyline){
    objArgs <- latLonCheck(objArgs, lat, lon, names(data), "add_polyline")
  }

  logicalCheck(update_map_view)
  numericCheck(digits)
  numericCheck(z_index)
  palette <- paletteCheck(palette)

  lst <- polyIdCheck(data, id, usePolyline, objArgs)
  data <- lst$data
  objArgs <- lst$objArgs
  ## END PARAMETER CHECKS



  allCols <- polylineColumns()
  requiredCols <- requiredLineColumns()
  colourColumns <- lineAttributes(stroke_colour)

  shape <- createMapObject(data, allCols, objArgs)
  colours <- setupColours(data, shape, colourColumns, palette)

  if(length(colours) > 0){
    shape <- replaceVariableColours(shape, colours)
  }

  requiredDefaults <- setdiff(requiredCols, names(shape))
  if(length(requiredDefaults) > 0){
    shape <- addDefaults(shape, requiredDefaults, "polyline")
  }

  if(!usePolyline){

    ids <- unique(shape[, id])
    n <- names(shape)[names(shape) %in% objectColumns("polylineCoords")]
    keep <- setdiff(n, c('id', 'lat', 'lng'))

    lst_polyline <- objPolylineCoords(shape, ids, keep)

    shape <- jsonlite::toJSON(lst_polyline, digits = digits, auto_unbox = T)

  }else{

    n <- names(shape)[names(shape) %in% objectColumns("polylinePolyline")]
    shape <- shape[, n, drop = FALSE]

    shape <- jsonlite::toJSON(shape, auto_unbox = T)
  }

  invoke_method(map, data, 'add_polylines', shape, update_map_view, layer_id, usePolyline)
}

#' @rdname clear
#' @export
clear_polylines <- function(map, layer_id = NULL){
  layer_id <- layerId(layer_id)
  invoke_method(map, data = NULL, 'clear_polylines', layer_id)
}
